{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte",
    "../src/game/components/Board.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport Host from './host/Host.svelte';\n\timport Game from './game/Game.svelte';\n</script>\n\n<style>\n\t.container {\n\t\theight: 100%;\n\t\twidth: 100%;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\toverflow: auto;\n\t}\n\t.container div {\n\t\tpadding: 10px;\n\t}\n\t.game-section {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n</style>\n\n<div class=\"container\">\n\t<div class=\"host-section\">\n\t\t<Host/>\n\t</div>\n\t\n\t<div class=\"game-section\">\n\t\t<Game/>\n\t</div>\n</div>\n",
    "<script>\n    import * as Honeycomb from 'honeycomb-grid';\n    import { SVG } from '@svgdotjs/svg.js'\n    import { onMount, createEventDispatcher } from 'svelte';\n    import { BOARD_SIZE, PLAYER_COLORS } from '../../constants';\n\n    let targetElement;\n    let Hex;\n    let Grid;\n    let grid;\n\n    export let gameState = null;\n    const dispatch = createEventDispatcher();\n\n    $: updateGameState(gameState);\n\n    onMount(() => {\n        const draw = SVG(targetElement);\n\n        Hex = Honeycomb.extendHex({\n            size: 30,\n            playerPiece: null,\n\n            render(draw) {\n                const { x, y } = this.toPoint();\n                const corners = this.corners();;\n\n                this.draw = draw\n                    .polygon(corners.map(({ x, y }) => `${x},${y}`))\n                    .fill('none')\n                    .stroke({ width: 1, color: '#999' })\n                    .translate(x, y);\n\n                if (this.q === 0) {\n                    this.renderEdges(draw, [2,3,4], PLAYER_COLORS[2]);\n                } else if (this.q === BOARD_SIZE - 1) {\n                    this.renderEdges(draw, [5,0,1], PLAYER_COLORS[2]);\n                }\n                \n                if (this.r === 0) {\n                    this.renderEdges(draw, [4,5,0], PLAYER_COLORS[1]);\n                } else if (this.r === BOARD_SIZE - 1) {\n                    this.renderEdges(draw, [1,2,3], PLAYER_COLORS[1]);\n                }\n\n            },\n\n            renderEdges(draw, cornerIndexes, color) {\n                const { x, y } = this.toPoint();\n                const corners = this.corners();\n                \n                draw.polyline(cornerIndexes.map(cornerIndex => [corners[cornerIndex].x, corners[cornerIndex].y]))\n                    .fill('none')\n                    .stroke({ width: 3, color })\n                    .translate(x, y);\n            },\n\n            setPlayerPiece(playerPiece) {\n                if (playerPiece !== this.playerPiece) {\n                    this.playerPiece = playerPiece;\n                    this.updateColor();\n                }\n            },\n\n            updateColor() {\n                switch(this.playerPiece) {\n                    case 1:\n                        this.draw\n                            .fill({ opacity: 1, color: PLAYER_COLORS[1] });\n                        break;\n                    case 2:\n                        this.draw\n                            .fill({ opacity: 1, color: PLAYER_COLORS[2] });\n                        break;\n                    default:\n                        this.draw\n                            .fill({ opacity: 1, color: 'none' });\n                        break;\n                }\n            }\n        });\n\n        Grid = Honeycomb.defineGrid(Hex);\n        grid = Grid.parallelogram({ \n            width: BOARD_SIZE, \n            height: BOARD_SIZE,\n            onCreate(hex) {\n                hex.render(draw);\n            }\n        });\n\n        forceSVGSizeToMatchContent();\n    });\n\n    function clickHex(event) {\n        const offsetX = event.pageX - targetElement.getBoundingClientRect().left - window.scrollX;\n        const offsetY = event.pageY - targetElement.getBoundingClientRect().top  - window.scrollY;\n        const hexCoordinates = Grid.pointToHex([offsetX, offsetY]);\n        const clickedHex = grid.get(hexCoordinates);\n        if (clickedHex && !clickedHex.playerPiece) {\n            dispatch('play', clickedHex);\n        }\n    }\n\n    function updateGameState(state) {\n        console.log('updating state !', state);\n        if (!state) return;\n        updateGrid(state.grid);\n    }\n\n    function updateGrid (gridData) {\n        gridData.forEach(hexData => {\n            const hex = grid.get({ x: hexData.x, y: hexData.y });\n            if (hex) {\n                hex.setPlayerPiece(hexData.playerPiece);\n            }\n        })\n    }\n\n    function forceSVGSizeToMatchContent() {\n        const bbox=targetElement.getBBox();\n        targetElement.setAttribute(\"viewBox\", (bbox.x-10)+\" \"+(bbox.y-10)+\" \"+(bbox.width+20)+\" \"+(bbox.height+20));\n        targetElement.setAttribute(\"width\", (bbox.width+20)  + \"px\");\n        targetElement.setAttribute(\"height\",(bbox.height+20) + \"px\");\n    }\n</script>\n\n<style>\n    .flex-1 {\n        flex: 1;\n    }\n</style>\n\n<div class=\"flex-1\">\n    <svg \n        bind:this={targetElement} \n        on:click={clickHex}>\n    </svg>\n</div>"
  ],
  "names": [],
  "mappings": "AAMC,UAAU,cAAC,CAAC,AACX,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,QAAQ,CAAE,IAAI,AACf,CAAC,AACD,wBAAU,CAAC,GAAG,cAAC,CAAC,AACf,OAAO,CAAE,IAAI,AACd,CAAC,AACD,aAAa,cAAC,CAAC,AACd,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AACvB,CAAC;AC4GE,OAAO,cAAC,CAAC,AACL,IAAI,CAAE,CAAC,AACX,CAAC"
}