{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte",
    "../src/game/Game.svelte",
    "../src/game/components/Board.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport Host from './host/Host.svelte';\n\timport Game from './game/Game.svelte';\n</script>\n\n<style>\n\t.container {\n\t\theight: 100%;\n\t\twidth: 100%;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\toverflow: auto;\n\t}\n\t.container div {\n\t\tpadding: 10px;\n\t}\n\t.game-section {\n\t\tflex: 1;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n</style>\n\n<div class=\"container\">\n\t<div class=\"host-section\">\n\t\t<Host/>\n\t</div>\n\t\n\t<div class=\"game-section\">\n\t\t<Game/>\n\t</div>\n</div>\n",
    "<script>\n    import Board from './components/Board.svelte';\n    import PlayersList from './components/PlayersList.svelte';\n    import Peer from 'peerjs';\n\n    let connectionToHost = null;\n    let connectedToHostId = null;\n    let hostId = null;\n\n    let gameState = null;\n    let players = [];\n\n    const peer = new Peer();\n\n    window.addEventListener(\"beforeunload\", function (e) {\n        if (connectionToHost) {\n            connectionToHost.close();\n        }\n    }, false);\n\n    function connect() {\n        connectionToHost = peer.connect(hostId);\n        connectionToHost.on('open', () => {\n            connectedToHostId = hostId;\n            connectionToHost.send({\n                request: 'state'\n            });\n            connectionToHost.send({\n                request: 'players'\n            });\n        });\n        connectionToHost.on('data', (data) => {\n            console.log('data received', data);\n            if (data.type === 'state') {\n                gameState = data.data;\n            } else if (data.type === 'players') {\n                players = data.data;\n            }\n        });\n    }\n\n    function sendPlayAction(event) {\n        if (!connectionToHost) return;\n        connectionToHost.send({\n            action: 'play',\n            data: {\n                x: event.detail.x,\n                y: event.detail.y\n            }\n        });\n    }\n</script>\n\n<style>\n    .horizontal-flex {\n        display: flex;\n        flex-direction: row;\n    }\n\n    .flex-1 {\n        flex: 1;\n    }\n</style>\n\n<h1>Game</h1>\n\n<div>\n    <input bind:value={hostId}>\n    <button \n        on:click={connect} \n        disabled={hostId === connectedToHostId}>\n        Connect\n    </button>\n</div>\n\n{#if connectionToHost || !connectionToHost}\n<div class=\"horizontal-flex\">\n    <div>\n        <Board {gameState} {players} on:play={sendPlayAction}/>\n    </div>\n    <div class=\"flex-1\">\n        <PlayersList {players} />\n    </div>\n</div>   \n{/if}",
    "<script>\n    import * as Honeycomb from 'honeycomb-grid';\n    import { SVG } from '@svgdotjs/svg.js'\n    import { onMount, createEventDispatcher } from 'svelte';\n    import { BOARD_SIZE, PLAYER_COLORS } from '../../constants';\n\n    let targetElement;\n    let Hex;\n    let Grid;\n    let grid;\n\n    export let gameState = null;\n    export let players = [];\n    const dispatch = createEventDispatcher();\n\n    $: updateGameState(gameState);\n\n    onMount(() => {\n        const draw = SVG(targetElement);\n\n        Hex = Honeycomb.extendHex({\n            size: 30,\n            playerPiece: null,\n\n            render(draw) {\n                const { x, y } = this.toPoint();\n                const corners = this.corners();;\n\n                this.draw = draw\n                    .polygon(corners.map(({ x, y }) => `${x},${y}`))\n                    .fill('none')\n                    .stroke({ width: 1, color: '#999' })\n                    .translate(x, y);\n\n                if (this.q === 0) {\n                    this.renderEdges(draw, [2,3,4], PLAYER_COLORS[2]);\n                } else if (this.q === BOARD_SIZE - 1) {\n                    this.renderEdges(draw, [5,0,1], PLAYER_COLORS[2]);\n                }\n                \n                if (this.r === 0) {\n                    this.renderEdges(draw, [4,5,0], PLAYER_COLORS[1]);\n                } else if (this.r === BOARD_SIZE - 1) {\n                    this.renderEdges(draw, [1,2,3], PLAYER_COLORS[1]);\n                }\n\n            },\n\n            renderEdges(draw, cornerIndexes, color) {\n                const { x, y } = this.toPoint();\n                const corners = this.corners();\n                \n                draw.polyline(cornerIndexes.map(cornerIndex => [corners[cornerIndex].x, corners[cornerIndex].y]))\n                    .fill('none')\n                    .stroke({ width: 3, color })\n                    .translate(x, y);\n            },\n\n            setPlayerPiece(playerPiece) {\n                if (playerPiece !== this.playerPiece) {\n                    this.playerPiece = playerPiece;\n                    this.updateColor();\n                }\n            },\n\n            updateColor() {\n                switch(this.playerPiece) {\n                    case 1:\n                        this.draw\n                            .fill({ opacity: 1, color: PLAYER_COLORS[1] });\n                        break;\n                    case 2:\n                        this.draw\n                            .fill({ opacity: 1, color: PLAYER_COLORS[2] });\n                        break;\n                    default:\n                        this.draw\n                            .fill({ opacity: 1, color: 'none' });\n                        break;\n                }\n            }\n        });\n\n        Grid = Honeycomb.defineGrid(Hex);\n        grid = Grid.parallelogram({ \n            width: BOARD_SIZE, \n            height: BOARD_SIZE,\n            onCreate(hex) {\n                hex.render(draw);\n            }\n        });\n\n        forceSVGSizeToMatchContent();\n    });\n\n    function clickHex(event) {\n        if (gameState.win) return;\n        const offsetX = event.pageX - targetElement.getBoundingClientRect().left - window.scrollX;\n        const offsetY = event.pageY - targetElement.getBoundingClientRect().top  - window.scrollY;\n        const hexCoordinates = Grid.pointToHex([offsetX, offsetY]);\n        const clickedHex = grid.get(hexCoordinates);\n        if (clickedHex && !clickedHex.playerPiece) {\n            dispatch('play', clickedHex);\n        }\n    }\n\n    function updateGameState(state) {\n        console.log('updating state !', state);\n        if (!state) return;\n        updateGrid(state.grid);\n    }\n\n    function updateGrid (gridData) {\n        gridData.forEach(hexData => {\n            const hex = grid.get({ x: hexData.x, y: hexData.y });\n            if (hex) {\n                hex.setPlayerPiece(hexData.playerPiece);\n            }\n        })\n    }\n\n    function forceSVGSizeToMatchContent() {\n        const bbox=targetElement.getBBox();\n        targetElement.setAttribute(\"viewBox\", (bbox.x)+\" \"+(bbox.y)+\" \"+(bbox.width)+\" \"+(bbox.height));\n        targetElement.setAttribute(\"width\", (bbox.width)  + \"px\");\n        targetElement.setAttribute(\"height\",(bbox.height) + \"px\");\n    }\n</script>\n\n<style>\n    svg {\n        overflow: visible;\n    }\n</style>\n\n<svg \n    bind:this={targetElement} \n    on:click={clickHex}>\n</svg>"
  ],
  "names": [],
  "mappings": "AAMC,UAAU,cAAC,CAAC,AACX,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,QAAQ,CAAE,IAAI,AACf,CAAC,AACD,wBAAU,CAAC,GAAG,cAAC,CAAC,AACf,OAAO,CAAE,IAAI,AACd,CAAC,AACD,aAAa,cAAC,CAAC,AACd,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AACvB,CAAC;ACkCE,gBAAgB,cAAC,CAAC,AACd,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,AACvB,CAAC,AAED,OAAO,cAAC,CAAC,AACL,IAAI,CAAE,CAAC,AACX,CAAC;ACqED,GAAG,eAAC,CAAC,AACD,QAAQ,CAAE,OAAO,AACrB,CAAC"
}